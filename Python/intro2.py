# -*- coding: utf-8 -*-
"""Intro2

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1k4AIGHO78LTivrFzwcqpItqkFSoiR9ZX

# **Python Intermediate** 

[github.com/whythawk](github.com/whythawk/intro-to-python)

[github.com/webartifex](https://github.com/webartifex/intro-to-python/blob/master/10_classes_00_content.ipynb) (Para la parte de Classes)

# Funciones
Las funciones son módulos de código invocables, algunos con parámetros o argumentos (variables que puede pasar a la función), que realiza una tarea y puede devolver un valor. Son una forma conveniente de empaquetar código en bloques discretos, lo que hace que el programa sea más legible, reutilizable y ahorre tiempo.

* `return` es opcional, pero le permite devolver los resultados de cualquier tarea realizada por la función al punto donde se llamó a la función
"""

# Función simple sin argumentos (def function_name(parámetros):)
def say_hello():
    print("Hello, World!")

# Llamar función
say_hello()

# Testearla
print(callable(say_hello))

"""Un argumento puede ser cualquier variable, como números enteros, *strings*, listas, diccionarios o incluso otras funciones. 

Es importante dejar comentarios y explicaciones en tu código porque necesitas asegurarte de que cualquiera que use una función sepa qué variables espera la función, y en qué orden.

Las funciones también pueden realizar cálculos.
"""

# Una función con dos argumentos string
def say_hello_to_user(username, greeting):
    # Devuelve saludo a un nombre
    print("Hello, {}! I hope you have a great {}.".format(username, greeting))

# Hay que "llamarla" (to call it)
say_hello_to_user("Jill", "day")

# Realizar un cálculo
def sum_two_numbers(x, y):
    # Devolver resultado
    return x + y

sum_two_numbers(5, 10)

# Realizar un cálculo
def sum_two_numbers2(x, y):
    # Devolver resultado
    print(x + y)

sum_two_numbers2(5, 10)

"""* *print* sólo muestra al usuario un string que representa lo que está pasando dentro de la computadora. La computadora no puede hacer uso de esa impresión. 

* *return* es como una función que devuelve un valor. Este valor a menudo no es visto por el usuario humano, pero puede ser usado por la computadora en otras funciones.
"""

def add_three(num):
    return num + 3

x1 = sum_two_numbers(5, 10)

x2 = sum_two_numbers2(5, 10)

print (x1)
print (x2)

x3 = add_three(x1)
print (x3)
x4 = add_three(x2)
print (x4)

"""No sólo se pueden llamar funciones desde las funciones, sino que también se pueden crear variables que son funciones, o el resultado de las funciones."""

def number_powered(number, exponent):
    # Devuelve el numero alevado al exponente
    return number ** exponent

# `sum_two_numbers` sigue disponible
def sum_and_power(number1, number2, exponent):
    # Devuelve los dos números sumados, y luego exponenciados
    summed = sum_two_numbers(number1, number2)
    return number_powered(summed, exponent)

# `sum_and_power`
print(sum_and_power(2, 3, 4))

"""Otra forma de comentar tus archivos es usando *docstrings*:  texto entre 3 comillas dobles para comentar

También se puede usar llamando a esta función: 
`function.__ doc__`
"""

def docstring_example():
    """
    An example function which returns `True`.
    """
    return True

# Imprimir el comentario
print(docstring_example.__doc__)

# Call it
print(docstring_example())

"""# Clases y Objetos

Un objeto de Python completo es una encapsulación de ambas variables y funciones en una sola entidad. Los objetos obtienen sus variables y funciones de las *clases*.

Las clases son donde la mayor parte de la acción ocurre en Python y la codificación consiste, en gran medida, en producir y utilizar clases para realizar tareas.

Las clases siguen el paradigma objecte-oriented programming (OOP) donde un programa largo se divide en pequeños componentes (objetos) que reusan el codigo.

La clase solo se puede acceder con operadores de punto (class atributes).

Dentro de las clases, las funciones se vinculan como métodos que se utilizan con objetos futuros.

Una clase muy básica se vería así:
"""

class myClass:
    """
    A demonstration class.
    """
    my_variable = "Look, a variable!"
    
    def my_function(self):
        """
        A demonstration class function.
        """
        return "I'm a class function!"

# You call a class by creating a new class object
new_class = myClass()

# You can access class variables or functions with a dotted call, as follows
print(new_class.my_variable)
print(new_class.my_function())

# Access the class docstrings
print(myClass.__doc__)
print(myClass.my_function.__doc__)

"""* Se llama a una clase mediante `class()`. 

* Todas las variables y funciones de una clase se llaman mediante el punto (.): `.function()` o `.variable`. 

* Incluso puede agregar nuevas funciones y variables a una clase que ya se creó. 

* Sin embargo, no existirán en las nuevas clases que crees, ya que no has cambiado el código subyacente.

* Las funciones dentro de una clase requieren un argumento base que, por convención, se llama `self`. 

* Entonces, dentro de la clase, `self.function` es la forma en que la clase llama a sus funciones.
"""

class myClass:
    """
    A demonstration class.
    """
    my_variable = "Look, a variable!"
    
    def my_function(self):
        """
        A demonstration class function.
        """
        return "I'm a class function!"

# Agregar nueva variable
new_class1 = myClass()
new_class1.my_variable2 = "Hi, Bob!"
print(new_class1.my_variable2, new_class1.my_variable)

# But, trying to access my_variable2 in new_class causes an error
print(new_class1.my_variable2)

"""Las clases pueden inicializarse con un conjunto de variables ya disponibles. Esto hace que la referencia a *self* sea más explícita y también te permite pasar argumentos a su clase para establecer valores iniciales.

* Inicialice una clase con la función especial `def __init__(self)`: esto contiene la validación lógica requerida para "correr" la clase
* Pase argumentos a sus funciones con `__init__(self, arguments)`: atributos
* También podemos diferenciar entre argumentos y argumentos de palabras clave:
* **argumentos**: estos se pasan de la manera habitual, como un solo término: `my_function(argument)`.
* **argumentos de palabras clave**: estos se pasan de la forma en que se pensaría en un diccionario: `my_function(keyword_argument = value)`. Esta es también una forma de inicializar un argumento con un valor predeterminado. 
* Las funciones a menudo necesitan que se les pasen numerosos argumentos y argumentos de palabras clave.
* Se puede pensar en una lista de argumentos como una lista, y una lista de argumentos de palabras clave como un diccionario. 
* Una forma más ordenada de lidiar con esto es hacer referencia a sus argumentos y argumentos de palabras clave así: `my_function(*args,**kwargs)` donde `*args` estará disponible para la función como una lista ordenada, y `**kwargs` como un diccionario.
* No es necesario escribir `*args` o `**kwargs`. Sólo el `*` (asterisco) es necesario. También podrías haber escrito *var y **vars. Escribir *args y **kwargs es sólo una convención. ([Help](https://book.pythontips.com/en/latest/args_and_kwargs.html))
* `*args` y `**kwargs` te permiten pasar un número variable de argumentos a una función.
* Al tratar `**kwargs` como un diccionario podemos usar los métodos para diccionarios: [Built-in Types](https://docs.python.org/3/library/stdtypes.html#dict.items)
"""

def test_args_kwargs(arg1, arg2, arg3):
    print("arg1:", arg1)
    print("arg2:", arg2)
    print("arg3:", arg3)

#Now you can use *args or **kwargs to pass arguments to this little function. Here’s how to do it:

# first with *args
args = ("two", 3, 5)
test_args_kwargs(*args)

# now with **kwargs:
kwargs = {"arg3": 3, "arg2": "two", "arg1": 5}
test_args_kwargs(**kwargs)

class demoClass:
    """
    A demonstration class with an __init__ function, and a function that takes args and kwargs.
    """
    
    def __init__(self, argument = None):
        """
        A function that is called automatically when the demoClass is initialised.
        """
        self.demo_variable = "Hello, World!"
        self.initial_variable = argument
        
    def demo_class(self, *args, **kwargs):
        """
        A demo class that loops through any args and kwargs provided and prints them.
        """
        for i, a in enumerate(args):
            print("Arg {}: {}".format(i+1, a))
        for k, v in kwargs.items():
            print("{} - {}".format(k, v))
        if kwargs.get(self.initial_variable):
            print(self.demo_variable)
        return True

demo1 = demoClass()
demo2 = demoClass("Bob")

# What was initialised in each demo object?
print(demo1.demo_variable, demo1.initial_variable)
print(demo2.demo_variable, demo2.initial_variable)

# A demo of passing arguments and keyword arguments
args = ["Alice", "Bob", "Carol", "Dave"]
kwargs = {"Alice": "Engineer",
          "Bob": "Consultant",
          "Carol": "Lawyer",
          "Dave": "Doctor"
         }

demo2.demo_class(*args, **kwargs)

"""El uso de `*args` y `**kwargs` en tus llamadas a una función mientras estás programando hace más fácil cambiar tu código sin tener que volver a cada línea de código que llama a tu función y corregir errores cuando cambias el orden o el número de argumentos que estás llamando.

Esto reduce los errores, mejora la legibilidad y hace que la experiencia de codificación sea más agradable y eficiente.

Haremos otro ejemplo usando [Special method names](https://docs.python.org/3/reference/datamodel.html#special-method-names).

Los elementos proporcionados por el argumento de *data* se proyectan primero como objetos *float* y luego se almacenan en un objeto de lista llamado _entries, que es un objeto nuevo.
"""

# Text representations

class Vector:

    def __init__(self, data):
        self._entries = list(float(x) for x in data)
        # ...

    def __repr__(self):
        args = ", ".join(f"{x:.2f}" for x in self._entries)
        return f"Vector(({args}))"
    
    def __str__(self):
        first, last = self._entries[0], self._entries[-1]
        n_entries = len(self._entries)
        return f"Vector({first:.1f}, ..., {last:.1f})[{n_entries:d}]"

# object.__str__() method differs from object.__repr__() in that 
# there is no expectation that __str__() return a valid Python expression.

v = Vector([1, 2, 3])

v

repr(v)

str(v)

"""### Computed properties

* Una matriz exhibe ciertas propiedades que dependen sólo de los datos concretos encapsulados en ella y que no pueden fijarse en algún valor arbitrario. 

* Por ejemplo, cada Matriz tiene implícitamente dos dimensiones: el número de filas y columnas.

* Diseñaremos nuestra clase Matrix de tal manera que las instancias tienen dos atributos, n_filas y n_cols. 

* Para ello, utilizamos property() incorporada con una sintaxis @ especial e implementamos atributos derivados que se calculan a partir del estado actual de un objeto. 

* Funcionan como métodos, excepto que no necesitan ser invocados con el operador de llamada (), sino que se puede acceder a ellos como si fueran variables.
"""

# Computed properties

class Matrix:

    def __init__(self, data):
        self._entries = list(list(float(x) for x in r) for r in data)
        for row in self._entries[1:]:
            if len(row) != self.n_cols:
                raise ValueError("rows must have the same number of entries")
        if self.n_rows == 0:
            raise ValueError("a matrix must have at least one entry")

    def __repr__(self):
        args = ", ".join("(" + ", ".join(f"{c:.3f}" for c in r) + ",)" for r in self._entries)
        return f"Matrix(({args}))"

    @property
    def n_rows(self):
        return len(self._entries)

    @property
    def n_cols(self):
        return len(self._entries[0])

m = Matrix([(1, 2, 3), (4, 5, 6)])

m.n_rows, m.n_cols

m

"""# Módulos y paquetes
Un módulo en Python es un conjunto de clases o funciones que encapsulan un conjunto único y relacionado de tareas. Los paquetes son un conjunto de módulos reunidos en una sola unidad. Esto también puede ser llamado una biblioteca.

Crear un módulo es tan simple como guardar el código de la clase en un archivo con la extensión .py.

## Módulos de escritura
Un conjunto de módulos en una biblioteca requieren tener un conjunto específico de requisitos. 

* Imaginen que deseamos desarrollar un juego de ping pong. Podemos colocar la lógica del juego en un módulo, y la funcionalidad para jugar el juego en otro. Eso nos lleva a una carpeta con la siguiente estructura de archivos:

*pingpong/*

*pingpong/game.py*

*pingpong/draw.py*

* Dentro de cada archivo habrá un conjunto de funciones. 

* Supongamos que, dentro de *draw.py* hay una **función** llamada *draw_game*. 

* Si quisieras importar la función *draw_game* al archivo *game.py*, la convención es la siguiente:

*import draw*

* Esto importará todo lo que está en el archivo draw.py. 

* Después de eso, se accede a las funciones del archivo haciendo llamadas a, por ejemplo, *draw.draw_game*.

* O bien, puedes acceder directamente a cada archivo y sólo importar lo que necesites (ya que algunos archivos pueden ser extremadamente grandes y no necesariamente deseas importar todo):

*from draw import draw_game*

* Cuando ejecutas un programa directamente desde la línea de comandos, necesitas una función especial llamada *main*, que se ejecuta de la siguiente manera:

    `if __name__ == '__main__':`

          `main()`
"""

# game.py
# Import the draw_game function from draw.py
from draw import draw_game

def play_game():
    ...

def main():
    result = play_game()
    draw_game(result)

# If this script is executed, then main() will be executed
if __name__ == '__main__':
    main()

"""* Las funciones y clases de Python se pueden guardar para reutilizarlas en archivos con la extensión `.py`

* Podés importar las funciones de esos archivos usando `import filename` (sin la extensión` .py`) o funciones o clases específicas de ese archivo con `from filename import class, function1, function2`

* Después de ejecutar el programa, Python crea automáticamente un archivo con el mismo nombre, pero con `.pyc` como extensión. Esta es una versión compilada del archivo y ocurre automáticamente.

* Si un módulo tiene una gran cantidad de funciones que querés utilizar en tu propio código, podés especificar un nombre personalizado para su uso. 

* Por ejemplo, un módulo que conoceremos en la siguiente sección se llama `pandas`. La convención es importarlo como `import pandas as pd`. 

* Ahora accederás a las funciones en `pandas` utilizando la notación de punto de` pd.function`.

Poniendo todo esto junto en un ejemplo de pseudocódigo (es decir, este código no funciona, así que no intente ejecutarlo):
"""

# game.py
# Import the draw module
if visual_mode:
    # in visual mode, we draw using graphics
    import draw_visual as draw
else:
    # In textual mode, we print out text
    import draw_textual as draw

def main():
    result = play_game()
    # this can either be visual or textual depending on visual_mode
    draw.draw_game(result)

"""# Módulos Built-in"""

#  Leer el manual de ayuda usando `help (module)` (va a mostrar los docstrings)
import pandas as pd

help(pd)

# Después de importar un módulo, `dir (module)` te permite ver una lista de todas las funciones implementadas en esa biblioteca.
dir(pd)

"""# Escribiendo paquetes

* Los paquetes son bibliotecas que contienen múltiples módulos y archivos. 
* Se almacenan en directorios y tienen un requisito importante: cada paquete es un directorio que **debe** contener un archivo de inicialización llamado `__init__.py`.

* El archivo puede estar completamente vacío, pero se importa y se ejecuta con la función de importación. 

* Esto permite establecer algunas reglas, o pasos iniciales a realizar con la primera importación del paquete.

* Python sólo importará (e inicializará) el paquete una vez.

* Una parte útil del archivo `__init__.py` es que se puede limitar lo que se importa con el comando `from package import *`.
"""

#__init__.py

__all__ = ["class1", "class2"]

"""Esto significa que de `from package import *` sólo importa la *class1* y *class2*.

# Data Analysis

## Matrices de números (Numpy arrays)

* El análisis de datos suele implicar la realización de operaciones sobre grandes cantidades de datos. 

* Numpy es un poderoso conjunto de herramientas que le permite trabajar rápida y fácilmente con listas de datos completas. 

* Nos referimos a estas listas como matrices.

* Por convención, importamos Numpy como np: *import numpy as np*

* También podemos querer generar un montón de listas de *floats* aleatorios para estos ejercicios. Python hace eso con el módulo *random*.
"""

import numpy as np
import random

def generate_float_list(lwr, upr, num):
    """
    Return a list of num random decimal floats ranged between lwr and upr.
    
    Range(lwr, upr) creates a list of every integer between lwr and upr.
    random.sample takes num integers from the range list, chosen randomly.
    """
    int_list = random.sample(range(lwr, upr), num)
    return [x/100 for x in int_list]

# Create two lists
height = generate_float_list(100, 220, 10)
weight = generate_float_list(5000, 20000, 10)

# Convert these to Numpy arrays
np_height = np.array(height)
np_weight = np.array(weight)

print(np_height)
print(np_weight)

"""Hay una útil función de temporizador incorporada. Inicia cualquier línea de código con *%time* y obtendrás la salida de cuánto tiempo tardó en ejecutarse el código.

Esto es importante cuando se trabaja con operaciones de datos intensivos en las que se quiere exprimir cada gota de eficiencia optimizando el código.

Ahora podemos realizar operaciones directamente en todos los valores de estas matrices Numpy. Aquí hay dos métodos sencillos de usar.

* **Element-wise calculations**: puede tratar las matrices de Numpy como lo haría con *floats* o *integers* individuales. Tenga en cuenta que deben tener la misma forma (es decir, número o elementos), o puede realizar operaciones bit a bit (operar en cada elemento de la matriz) con un solo float o integer
* **Filtering**: puede filtrar rápidamente matrices Numpy realizando operaciones booleanas: `np_array [np_array> num]`, o, para una respuesta puramente booleana, `np_array>num`
"""

# Commented out IPython magic to ensure Python compatibility.
# Calculate body-mass index based on the heights and weights in our arrays
# Time the calculation ... it won't be long
# %time bmi = np_weight / np_height ** 2

print(bmi)

# Any BMI > 35 is considered severely obese. Let's see who in our sample is at risk.

# Get a boolean response
print(bmi > 35)

# Or print only BMI values above 35
print(bmi[bmi > 35])

"""## Pandas 

* [Tutorial de Pandas](https://pandas.pydata.org/pandas-docs/stable/getting_started/10min.html)

* Pandas es un paquete de Python que proporciona estructuras de datos rápidas, flexibles y expresivas diseñadas para hacer que el trabajo con datos "relacionales" o "etiquetados" sea fácil e intuitivo. 

* Su objetivo es ser el bloque de construcción fundamental de alto nivel para hacer análisis de datos prácticos y del mundo real en Python. 

* Además, tiene el objetivo más amplio de convertirse en la herramienta de análisis / manipulación de datos de código abierto más potente y flexible disponible en cualquier idioma.

* Pandas permite manipular los datos ya sea como una serie (similar a Numpy, pero con características añadidas), o en una forma tabular con filas de valores y columnas con nombre (similar a la forma en que se puede pensar en una hoja de cálculo de Excel).

Esta forma tabular se conoce como *DataFrame*.

### Creación de objetos

Una *Series* genera una lista de valores con un índice entero por defecto (pero tiene una dimensión). Se suele usar para generar time series.
"""

import pandas as pd
import numpy as np

s = pd.Series([1,3,5,np.nan,6,8])
s

"""* *np.nan* es la forma por defecto de Numpy de presentar un valor como "no-un-número". 

* Por ejemplo, dividir por cero devuelve *np.nan*. Esto significa que puede realizar operaciones complejas de forma relativamente segura y solucionar los daños posteriormente.
"""

# Crea un DataFrame pasando una matriz numpy, con un índice de fecha y hora y columnas etiquetadas - c/ ISO-formatted date (YYYYMMDD)
dates = pd.date_range('20130101', periods=6)
dates

"""Los números de la parte izquierda de una tabla (row name o primera columna) se llaman índice. Esto le permite hacer referencia a una fila específica. 

Sin embargo, Pandas le permite establecer su propio índice.

Puede establecer una de las columnas existentes como índice (siempre y cuando conste de valores únicos) o puede establecer un nuevo índice personalizado.
"""

# Create a dataframe using the date range we created above as the index
df = pd.DataFrame(np.random.randn(6,4), index=dates, columns=list('ABCD'))
df

# También podemos mezclar datos de texto y numéricos con un índice generado automáticamente.
dict = {"country": ["Brazil", "Russia", "India", "China", "South Africa"],
       "capital": ["Brasilia", "Moscow", "New Dehli", "Beijing", "Pretoria"],
       "area": [8.516, 17.10, 3.286, 9.597, 1.221],
       "population": [200.4, 143.5, 1252, 1357, 52.98] }

brics = pd.DataFrame(dict)
brics

# Set the ISO two-letter country codes as the index
brics.index = ["BR", "RU", "IN", "CH", "SA"]

brics

"""### Visualizar data

Pandas puede trabajar con conjuntos de datos excepcionalmente grandes, incluyendo millones de filas. Presentar eso ocupa espacio y, si sólo quieres ver cómo son tus datos (ya que, la mayoría de las veces, puedes trabajar con ellos simbólicamente), puede ser costoso. 

Pandas viene con varias formas de ver y revisar los datos.

* Ver las filas superior e inferior de su marco de datos con `df.head ()` o `df.tail (num)` donde `num` es un número entero de filas

* Ver el índice, las columnas y los datos numpy subyacentes con `df.index`,` df.columns` y `df.values`

* Obtener un resumen estadístico rápido de sus datos con `df.describe ()`

* Transponer los datos con `df.T`

* Ordenar por un eje con `df.sort_index (axis = 1, ascendente = False)` donde `axis = 1` se refiere a columnas y` axis = 0` se refiere a filas

* Ordenar por valores con `df.sort_values (by = column)`
"""

# Head
df.head()

# Tail
df.tail(3)

# Index
df.index

# Values
df.values

# Statistical summary
df.describe()

# Transpose
df.T

# Sort by an axis
df.sort_index(axis=1, ascending=False)

# Sort by values
df.sort_values(by="B")

"""### Selecciones

Uno de los primeros pasos en el análisis de datos es simplemente filtrar los datos y obtener las partes que más te interesan. Pandas tiene numerosos enfoques para conseguir rápidamente sólo lo que quieres.

* Seleccionar una sola columna dirigiendo el marco de datos como lo haría con un diccionario, con `df [columna]` o, si el nombre de la columna es una sola palabra, con `df.column`. Esto devuelve una serie

* Seleccione un segmento como lo haría con una lista de Python, con `df []`, p. `df [: 3]`, o cortando los índices, `df [" 20130102 ":" 20130104 "]`

* Usar `.loc` para seleccionar por etiquetas específicas, tales como:
* Obtenga una sección transversal basada en una etiqueta, con p. `df.loc [índice [0]]`

* Subir al eje múltiple por una etiqueta, con `df.loc[:,["A","B"]]` donde el primer `:` indica el segmento de filas, y la segunda lista `["A","B"] `indica la lista de columnas
* Como lo harías con Numpy, se puede obtener una selección booleana, por ejemplo, con `df [df.A> num]`
"""

# By column
df.A

# By slice
df["20130102":"20130104"]

# Cross-section
df.loc[dates[0]]

# Multi-axis
df.loc[:, ["A", "B"]]

# Boolean indexing
df[df.A > 0]

"""## Matplotlib
Matplotlib es una biblioteca de ploteo de Python.

**Matplotlib, Numpy y Pandas forman las tres herramientas más importantes en el análisis de datos.**
"""

# Commented out IPython magic to ensure Python compatibility.
import matplotlib.pyplot as plt
# Para que Matplotlib plots lo muestre en notebook.
# %matplotlib inline

# Produce a random timeseries
ts = pd.Series(np.random.randn(1000), index=pd.date_range('1/1/2000', periods=1000))

# Get the cumulative sum of the random numbers generated to mimic a historic data series
ts = ts.cumsum()

# And plot
ts.plot()

# Save
plt.savefig('timeseries.png')

# And do the same thing with a dataframe
df = pd.DataFrame(np.random.randn(1000, 4), index=ts.index,
                  columns=['A', 'B', 'C', 'D'])

df = df.cumsum()

# And plot, this time creating a figure and adding a plot and legend to it
df.plot()
plt.legend(loc='best')

# Save
plt.savefig('series.png')

"""# Leer archivos csv + Pandas"""

from google.colab import files
uploaded = files.upload()

import pandas as pd
import io
cars = pd.read_csv(io.StringIO(uploaded['Automobile_data.csv'].decode('utf-8')))

print(cars.shape)

print(cars.dtypes)

print(cars.head())

# Clean data and update the CSV file 

df = pd.read_csv(io.StringIO(uploaded['Automobile_data.csv'].decode('utf-8')), na_values={
'price':["?","n.a"],
'stroke':["?","n.a"],
'horsepower':["?","n.a"],
'peak-rpm':["?","n.a"],
'average-mileage':["?","n.a"]})
print(df)

#df.to_csv("")

# Find the most expensive car company name

df = df [['company','price']][df.price==df['price'].max()]
df

# Print All Toyota Cars details
cars = pd.read_csv(io.StringIO(uploaded['Automobile_data.csv'].decode('utf-8')))
car_Manufacturers = cars.groupby('company')
toyotaDf = car_Manufacturers.get_group('toyota')
toyotaDf

#  Count total cars per company
cars['company'].value_counts()

# Find each company’s highest price car
priceDf = car_Manufacturers['company','price'].max()
priceDf

# Find the average mileage of each car making company
df = pd.read_csv(io.StringIO(uploaded['Automobile_data.csv'].decode('utf-8')), na_values={
'price':["?","n.a"],
'stroke':["?","n.a"],
'horsepower':["?","n.a"],
'peak-rpm':["?","n.a"],
'average-mileage':["?","n.a"]})

# No funciona .mean si están los ?
car_Manufacturers = df.groupby('company')
mileageDf = car_Manufacturers['company','average-mileage'].mean()
mileageDf

# Sort all cars by Price column
cars = cars.sort_values(by=['price', 'horsepower'], ascending=False)
cars.head(5)

# Concatenate two data frames using the following conditions
GermanCars = {'Company': ['Ford', 'Mercedes', 'BMV', 'Audi'], 'Price': [23845, 171995, 135925 , 71400]}
carsDf1 = pd.DataFrame.from_dict(GermanCars)

japaneseCars = {'Company': ['Toyota', 'Honda', 'Nissan', 'Mitsubishi '], 'Price': [29995, 23600, 61500 , 58900]}
carsDf2 = pd.DataFrame.from_dict(japaneseCars)

carsDf = pd.concat([carsDf1, carsDf2], keys=["Germany", "Japan"])
carsDf

# Merge two data frames using the following condition
Car_Price = {'Company': ['Toyota', 'Honda', 'BMV', 'Audi'], 'Price': [23845, 17995, 135925 , 71400]}
carPriceDf = pd.DataFrame.from_dict(Car_Price)

car_Horsepower = {'Company': ['Toyota', 'Honda', 'BMV', 'Audi'], 'horsepower': [141, 80, 182 , 160]}
carsHorsepowerDf = pd.DataFrame.from_dict(car_Horsepower)

carsDf = pd.merge(carPriceDf, carsHorsepowerDf, on="Company")
carsDf